#Version 0.21.1
#Counter: 29
#WinCounter: 1
#Window 1
#TabInfo
TabText: Layer 0
TabRenamed: 0
TabNumber: 0
TabsetLayer: 0
#Control: Window1
X       : 0
Y       : 0
CX      : 697
CY      : 432
ControlLayer: 0
Title   : Rotmg 15.0 Auto loot bots Version 03
Class   : Window
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
BkColor : 0
SystemBkColor : BTNFACE
EnableC : 1
DefaultsClass : WS_SYSMENU
Style   : WS_DLGFRAME, WS_SYSMENU, WS_MINIMIZEBOX
TypStyle: {...}
ExStyle : WS_EX_DLGMODALFRAME
Local : 1
LastEditorEvent : 1

#Proc: (General)
--rewrite for speed impovments 13/05/2013
--speed at the cost of keeping functions inline, yes there is a big overhead for calling functions in euphoria
--speed at all cost
--the update packet will keep all code inline hoping for at least 3-4 times speed impovement
--i've profile the update packet funcion, its currently very slow,  calls to serval function that i'm bring in line removing on avagae 5 inst

with profile
constant SPEED_MULTIPLIER = 7.462686567164179E-5
--?SPEED_MULTIPLIER
constant SPEED_BASE=0.0034999999999999996
--?SPEED_BASE

--?SPEED_BASE + (SPEED_MULTIPLIER)


constant globallimt =4
integer globalcount
globalcount=0


function remove_line(sequence string, integer line)
sequence temp
integer len
  len=length(string)
  if line=1 then
    return string[2..len]
  elsif line=len then
    return string[1..len-1]
  else
    temp=string[1..line-1]
    return temp&string[line+1..len]
  end if
end function

function file_exsist(sequence fname)
  integer fn
  fn=open(fname,"r")
  if fn!=-1  then
    close(fn)
  	return 1
  end if
  return 0
end function

function real(sequence string)
sequence temp
temp=value(string)
return temp[2]
end function

global atom hMutex
integer arg
constant
    xSetLastError = registerw32Procedure(kernel32, "SetLastError",{C_INT}),
    xCreateMutex = registerw32Function(kernel32, "CreateMutexA",
                                                {C_POINTER,C_INT,C_POINTER},C_LONG),
    xReleaseMutex  = registerw32Procedure(kernel32, "ReleaseMutex",{C_LONG}),

	xScrollWindow = registerw32Procedure( user32, "ScrollWindow", {C_LONG,C_LONG,C_LONG,C_POINTER,C_POINTER} )

arg = allocate_string("looosdnms")
hMutex = w32Func(xCreateMutex,{0, 0, arg})
if w32Func(GetLastError,{}) = ERROR_ALREADY_EXISTS then
    w32Proc(xReleaseMutex,{hMutex})
    free(arg)
    --free_console()
    --abort(0)
end if


sequence accounts
accounts={}

procedure load_accounts()
  integer fn, count,number
  object line
  sequence buffer
  fn=open("accounts.txt","r")
  buffer={}
  while 1 do
  	line=gets(fn)
  	if integer(line) then
  	  exit	
  	end if
  	if line[length(line)]=10 then
  	  buffer=append(buffer,line[1..length(line)-1])
    else
      buffer=append(buffer,line[1..length(line)])
  	end if
  	
  end while	
	
  count=1
  number=floor(length(buffer)/4)
  for i=1 to number do
  	accounts=append(accounts,{buffer[count],buffer[count+1],buffer[count+2],buffer[count+3],0})
  	count+=4
  	if i>=globallimt then
  	  exit	
  	end if
  end for


  for i=1 to length(accounts) do
  	addItem(List_accounts,accounts[i][1]&":"&accounts[i][2]&":"&accounts[i][3]&":"&accounts[i][4])
  end for
end procedure
load_accounts()



--winsocket global vars
atom hWndMainWindow
constant SM_ASYNC = #FFFF
--integer packet_id,packet_len --global some functions might need to uses these

sequence server_list
server_list={
{"USWest","50.18.113.133"},
{"USMidWest","107.22.218.252"},
{"EUWest","46.137.187.86"},
{"USEast","184.72.218.199"},
{"AsiaSouthEast","46.137.247.5"},
{"USSouth","107.22.231.55"},
{"USSouthWest","50.18.176.194"},
{"EUEast","46.51.176.123"},
{"EUNorth","176.34.240.11"},  --9
{"EUSouthWest","176.34.240.126"},
{"USEast3","50.19.47.160"},
{"USWest2","184.169.130.44"},
{"USMidWest2","174.129.56.145"},
{"USEast2","23.21.243.164"},
{"USNorthWest","184.169.131.108"},
{"USSouth2","107.20.55.255"},
{"AsiaEast","46.137.218.95"},
{"USSouth3","204.236.195.161"},
{"EUSouth","176.34.71.225"},
{"EUNorth2","46.137.38.91"},
{"EUWest2","176.34.195.206"}
}

for i=1 to length(server_list) do
  addItem(combox_serverlist,server_list[i][1])	
end for
--setIndex(combox_serverlist,9)--eu north
setIndex(combox_serverlist,1)--us west


--with profile
--with profile_time
--profile(1)

include item_ids.ew
include SrvSckIP.ew
include client.ew
include math.ew
include win32extra.ew
include stream_write.ew


global procedure socket_send_data(integer socket,sequence data)
  integer len
  len=WsockSendData(socket,data)
  if len!=length(data) then
  	puts(1,"sending data error\n")
  end if
end procedure



--each socket is assinged a new instance of autolootbot_list
sequence sockets
sockets=repeat(0,65536) --this is used to index into the autolootbot_list



--handling the items and quick indexing code
sequence white_list
white_list={}

procedure load_items()
  integer fn
  object line
  sequence buffer
  fn=open("items.txt","r")
  buffer={}
  while 1 do
  	line=gets(fn)
  	if integer(line) then
  	  exit	
  	end if
  	buffer=append(buffer,line[1..length(line)-1])
  end while	
  white_list=buffer
end procedure

load_items()

sequence item_index
item_index=repeat({0,0,""},60000)

procedure init_items()
integer found
for i=1 to length(item_ids) do
  item_index[item_ids[i][1]][1]=item_ids[i][1]
  item_index[item_ids[i][1]][3]=item_ids[i][2]
  found=0
  for j=1 to length(white_list) do
  	if equal(white_list[j],item_ids[i][2])=1 then
  	  found=1
	  exit
  	end if
  end for
  if found=0 then
  	addItem(List_items,item_ids[i][2])
  else
    addItem(List_white_items,item_ids[i][2])
  end if
end for

setIndex(List_items,1)	
end procedure
init_items()


procedure mark_white_item()
sequence text

  for j=1 to length(item_ids) do
	 item_index[item_ids[j][1]][2]=0
  end for

  for i=1 to getCount( List_white_items ) do
  	text = getItem( List_white_items, i )
  	for j=1 to length(item_ids) do
	  if equal(item_index[item_ids[j][1]][3],text)=1 then
	    item_index[item_ids[j][1]][2]=1
	    exit 	
	  end if
    end for
  end for

end procedure

mark_white_item()
--gui item mangment



procedure connect_to_server()
	  integer iwork, port
	  atom Server_sock
  sequence swork,ip

  port = 2050

  iwork = WsockInit()
  if iwork = -1 then -- WinSock failed
    iwork = message_box("WSockInit() failed!","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
    abort(99)
  end if


  hWndMainWindow = getHandle(Window1)


  --Server_sock=Wsock_new("50.18.113.133", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))  --us west
  --Server_sock=Wsock_new("176.34.240.11", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT})) --eu north
  Server_sock=Wsock_new(server_list[getIndex(combox_serverlist)][2], 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))  --us west

end procedure




--connect_to_server()
--connect_to_server()

--connect_to_server()
--connect_to_server()

--connect_to_server()
--connect_to_server()



--setTimer(Window1,1001,1000*1) --this was used for rendering data

setTimer(Window1,1002,1000*1) --this is used for fixing the issue with fd_read being empty polling it is. also using this for a cool down timer


sequence my_stats
constant stats_size=100

my_stats=repeat({},stats_size)

--hello packet
global integer game_id,key_size
global atom key_time
global sequence key
key_size=0
game_id=-2
key_time=-1
key={}
--end hello packet

--mapinfo packet
global integer map_width,map_height
global sequence map_name
--end mapinfo packet

--sequence object_id_to_player_class
--object_id_to_player_class=repeat(0,4000000) --4 million objects

--required for packets
include packets.ew
include input_stream.ew
include mapinfo_packet.ew --includes around 10 addional packets
include hello_packet.ew
include text_packet.ew
include load_packet.ew
include create_suc_packet.ew
include players.ew



sequence autolootbots_list
autolootbots_list={}

constant autoloot_first_update=1
constant autoloot_first=2
constant autoloot_mx=3
constant autoloot_my=4
constant autoloot_tx=5
constant autoloot_ty=6
constant autoloot_object_id_to_player_class=7
constant autoloot_target_id=8 --not sure what this is now
constant autoloot_enable_move=9
constant autoloot_lootbag_id=10
constant autoloot_teleport_cooldown=11
constant autoloot_lootx=12
constant autoloot_looty=13
constant autoloot_itemtype=14
constant autoloot_timing=15
constant autoloot_px=16
constant autoloot_py=17

function autolootbot_create()
    --1first update
    --2first
    --3my x
    --4my y
    --5tx
    --6ty
    --7object_id_to_player_class
    --8target id
    --9 enable move
    --10current loot bag target id
    --11 teleport cool down timer
    --12 loot x
    --13 loot y
    --14 the loot stat {11,itemid,-1}
	autolootbots_list=append(autolootbots_list, {0,0,134,140,0,0,repeat(0,4000000),-1,1,0,0,0,0,0,0,0,0})
	return length(autolootbots_list)
end function





procedure process_update_packet(integer client,sequence data)
object object_type,object_id,stats
atom x,y,statdata_size
integer loc,inputstream,statdata_type
  --puts(1,"process_update_packet\n")
  object_type=int_to_bytes(782)
  object_id=int_to_bytes(client_list[client][client_object_id])

  loc=match({object_type[2], object_type[1], object_id[4],object_id[3],object_id[2],object_id[1]}, data)
  if loc=0 then
  	puts(1,"a serious error as happend\n")
  	return
  end if

  puts(1,"my stats updated\n")

  inputstream = input_stream_new()
  input_stream_set(inputstream, data[loc..length(data)])	


  stats=repeat({},stats_size) --the most number of stats a object can have

      object_type=input_stream_readshort(inputstream)
      object_id=input_stream_readint(inputstream)
      x=input_stream_readfloat(inputstream)
      y=input_stream_readfloat(inputstream)
      statdata_size=input_stream_readshort(inputstream)

      --?statdata_size
      for j=1 to statdata_size do
      	statdata_type=input_stream_readbyte(inputstream)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 then
          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}
        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
        end if

      end for
      --?stats
      --782 wizard
      if object_type=806 or object_type=805 or object_type=804 or object_type=803 or object_type=802 or object_type=801 or object_type=800
      or object_type=799 or object_type=798 or object_type=797 or object_type=784 or object_type=782 or object_type=775 or object_type=768 then
       -- integer object_id, sequence stats, sequence position, integer class,sequence position2d,sequence name
	    --object_id_to_player_class[object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"")
	    autolootbots_list[client_list[client][client_data]][7][object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"",client)
	
	    --?autolootbots_list[client_list[client][client_data]][7][object_id]
	
	    if object_id=client_list[client][client_object_id] then
	      autolootbots_list[client_list[client][client_data]][3]=x
	      autolootbots_list[client_list[client][client_data]][4]=y
	    end if
      end if


  --?object_type
  --?object_id
  --for i=1 to length(data)-6 do
 -- 	if data[i]=object_type[2] and data[i+1]=object_type[1] then
  --	  if data[i+2]=object_id[4] and data[i+3]=object_id[3] and data[i+4]=object_id[2] and data[i+5]=object_id[1] then
 -- 		puts(1,"found\n")
  --	  end if
 -- 	end if
 -- end for
  --?length(data)
  	--my guessing is the bytes at the end of the packet are my object
  	--update shouldent ever destory anything for the first update packet
  	-- noew i just need to read them quickly
end procedure


sequence loot_bag_ids
loot_bag_ids={}

procedure remove_loot_bag_id(integer id)
sequence data
  data={}
	for i=1 to length(loot_bag_ids) do
	  if loot_bag_ids[i]!=id then
	  	data&=loot_bag_ids[i]
	  end if
	end for
	loot_bag_ids=data
end procedure


procedure update_packet_read(integer client,integer inputstream)
  sequence temp
  integer player_handle,autoloot_handle
  --tiles
  sequence tiles
  integer tile_size,typee
  atom x,y

  --newobjs
  sequence newobjs,stats
  integer newobj_size,object_type,object_id,statdata_size,statdata_type
  integer dropsize

  sequence data,mystats,write
  atom found_loot,dist,dist_small,player_small
  autoloot_handle=client_list[client][client_data]




  tile_size=input_stream_readshort(inputstream)
  tiles={}

  if tile_size!=0 then --tiles

  	for i=1 to tile_size do
  	  x=input_stream_readshort(inputstream)
  	  y=input_stream_readshort(inputstream)
  	  typee=input_stream_readshort(inputstream)
  	  tiles=append(tiles,{x,y,typee})


    end for

  end if

  newobj_size=input_stream_readshort(inputstream)
  newobjs={}


  if newobj_size!=0 then --newobjs



  	for i=1 to newobj_size do

      stats=repeat({},stats_size) --the most number of stats a object can have

      object_type=input_stream_readshort(inputstream)
      object_id=input_stream_readint(inputstream)
      x=input_stream_readfloat(inputstream)
      y=input_stream_readfloat(inputstream)
      statdata_size=input_stream_readshort(inputstream)

      --?statdata_size
      for j=1 to statdata_size do
      	statdata_type=input_stream_readbyte(inputstream)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 then
          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}
        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
        end if

      end for
      --782 wizard
      if object_type=806 or object_type=805 or object_type=804 or object_type=803 or object_type=802 or object_type=801 or object_type=800
      or object_type=799 or object_type=798 or object_type=797 or object_type=784 or object_type=782 or object_type=775 or object_type=768 then
       -- integer object_id, sequence stats, sequence position, integer class,sequence position2d,sequence name
	    --object_id_to_player_class[object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"")
        autolootbots_list[autoloot_handle][7][object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"",client)
      end if

      if object_type=1280 then

      	--puts(1,"loot bag found\n")
      	--object_id_to_player_class[object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"")
      	autolootbots_list[autoloot_handle][7][object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"",client)
      	--for j=9 to 9+7 do
      	  --if stats[j][2]!=-1 then
      	  	--if item_index[ stats[j][2] ][2]=1  then
      	  	  --puts(1,"would loot\n")	
      	  	  --exit
      	  	--end if
      	  --end if
      	  --?stats[j]	
      	--end for
      	


      	for j=9 to 9+7 do
      	  --?stats[j]	
      	  if stats[j][2]!=-1 then
      	  	if item_index[stats[j][2]][2]=1  then--this means the item is on the auto loot list
      	  	  if find(object_id, loot_bag_ids)=0 and autolootbots_list[autoloot_handle][autoloot_teleport_cooldown]=0 then --loot bag as not been seen yet
      	  	    puts(1,"would loot "&item_index[stats[j][2]][3]&"\n")	
      	  	    --data=get_grid(x,y) --list of player handerles
      	  	    found_loot=0
      	  	    dist_small=10
      	  	    player_small=0
      	  	    for k=1 to length(player_class_list) do
      	  	      if length(player_class_list[k]) and player_class_list[k][player_client]=client then
      	  	        dist=point_distance(player_class_list[k][player_position][1],player_class_list[k][player_position][2],x,y)
      	  	        if dist<dist_small then
      	  	          dist_small=dist	
      	  	          player_small=k
      	  	        end if
                  end if
                end for

      	  	     mystats=player_stats_get(autolootbots_list[autoloot_handle][7][ client_list[client][client_object_id] ])
      	  	        for l=13 to 13+7 do
      	  	          if mystats[l][2]=-1 then
      	  	            puts(1,"found\n")
      	  	 	        autolootbots_list[autoloot_handle][autoloot_target_id]=player_class_list[player_small][player_object_id]
      	  	 	        write=""
      	  	 	        autolootbots_list[autoloot_handle][autoloot_enable_move]=0
  	                    write=writeint(write,player_class_list[player_small][player_object_id])
                        temp=reverse(int_to_bytes(length(write)+5)) &49
                        write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
                        socket_send_data(client_list[client][client_socket],temp&write)
                        loot_bag_ids&=object_id
                        autolootbots_list[autoloot_handle][autoloot_lootbag_id]=object_id
                        autolootbots_list[autoloot_handle][autoloot_lootx]=x
                        autolootbots_list[autoloot_handle][autoloot_looty]=y
                        found_loot=1
                        exit --l
                      end if
                    end for--l

      	  	    exit --j
      	  	  end if
      	  	end if
      	  end if
      	end for--j
      	
      end if

    end for



  end if


  dropsize=input_stream_readshort(inputstream)
  --if autolootbots_list[client_list[client][client_data]][1]=0 and dropsize!=0 then
  --	puts(1,"updated kabamed\n")
  --end if
  for i=1 to dropsize do
  	 object_id=input_stream_readint(inputstream)
  	
     --if object_id_to_player_class[object_id]!=0 then --object to be deleted is a player
     player_handle=autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][object_id]
     if  player_handle!=0 then
       player_delete(player_handle)
       autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][object_id]=0
     end if
  	
  end for


  if autolootbots_list[autoloot_handle][1]=0 then --required first update logic
    autolootbots_list[autoloot_handle][1]=1
  end if


  --UPDATEATT = 11;
  temp=reverse(int_to_bytes(length("")+5)) &updateatt_packet

  socket_send_data(client_list[client][client_socket],temp)
end procedure
packet_read_id[update_packet+1]=routine_id("update_packet_read")



procedure inv_swap(sequence myslot, sequence there_slot, integer myid, integer thereid, atom x, atom y, integer client)
  sequence write,temp
  	--1 is the stat id
  	--2 is the item id
  	--3 is ?
  	--?myslot
  	--?there_slot
  	
    --bado.writeInt(time_);
	--	position_.writeToOutput(bado);
	--	slotObject1_.writeToOutput(bado);
	--	slotObject2_.writeToOutput(bado);
  	
   -- bado.writeInt(objectId); --this is the object id owner
	--	bado.writeByte(slotId);
	--	bado.writeShort(itemType);
  autolootbots_list[client_list[client][client_data]][14]=there_slot[2]
  write=""
   --time
  write=writeint(write,current_time())
  --position
  write=writefloat(write,x)
  write=writefloat(write,y)

  --INVSWAP [18993 , location [134.68716, 140.44598] , item [591921, 0, 2711] , item [591921, 4, -1]]
  --my stats
  --11 -1
  ---thyere
  --8 2711 0

  write=writeint(write,myid)
  write=writebyte(write,myslot[1]-8)
  write=writeshort(write,myslot[2])

  write=writeint(write,thereid)
  write=writebyte(write,there_slot[1]-8)
  write=writeshort(write,there_slot[2])


  --INVSWAP = 65;
  temp=reverse(int_to_bytes(length(write)+5)) &65
  write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
  socket_send_data(client_list[client][client_socket],temp&write)
end procedure

atom speed
speed=SPEED_BASE + (SPEED_MULTIPLIER)


procedure move(integer client,integer autoloot_handle)
atom mx,my,tx,ty,angle,stime

sequence stats, mystats



  mx=autolootbots_list[autoloot_handle][autoloot_mx]
  my=autolootbots_list[autoloot_handle][autoloot_my]
  --autolootbots_list[autoloot_handle][autoloot_px]=mx
  --autolootbots_list[autoloot_handle][autoloot_py]=my
  tx=autolootbots_list[autoloot_handle][autoloot_tx]
  ty=autolootbots_list[autoloot_handle][autoloot_ty]

  ?mx
  ?my
  ?autolootbots_list[autoloot_handle][autoloot_px]
  ?autolootbots_list[autoloot_handle][autoloot_py]

  --?current_time()-client_list[client][client_last_move_time]

  if autolootbots_list[autoloot_handle][autoloot_enable_move]=1 and point_distance( mx, my, tx, ty)>1 then
    --?point_distance( autolootbots_list[client_list[client][client_data]][3], autolootbots_list[client_list[client][client_data]][4], autolootbots_list[client_list[client][client_data]][5], autolootbots_list[client_list[client][client_data]][6])
    angle=get_angle_to(mx,my,tx,ty)

    stime=current_time()-client_list[client][client_last_move_time]

    --if client=1 then
    --?(stime * speed)*sin(degtorad(angle))
    --end if
      if stime>600 then
      	stime=600
      end if


    --autolootbots_list[autoloot_handle][autoloot_mx]+=(stime * speed)*sin(degtorad(angle))
    --autolootbots_list[autoloot_handle][autoloot_my]-=(stime * speed)*cos(degtorad(angle))

  elsif autolootbots_list[autoloot_handle][autoloot_enable_move]=0 and point_distance( mx, my, autolootbots_list[autoloot_handle][autoloot_lootx], autolootbots_list[autoloot_handle][autoloot_looty])>0.6 then
    puts(1,"moving in teleport function\n")
    angle=get_angle_to(mx,my,tx,ty)
    speed=SPEED_BASE + (SPEED_MULTIPLIER)
    stime=current_time()-client_list[client][client_last_move_time]
    --if client=1 then
    --?(stime * speed)*sin(degtorad(angle))
    --end if
      if stime>600 then
      	stime=600
      end if

  	angle=get_angle_to(mx,my ,autolootbots_list[autoloot_handle][autoloot_lootx],autolootbots_list[autoloot_handle][autoloot_looty])
    --autolootbots_list[autoloot_handle][autoloot_mx]+=(stime * speed)*sin(degtorad(angle))
    --autolootbots_list[autoloot_handle][autoloot_my]-=(stime * speed)*cos(degtorad(angle))
  else
    if autolootbots_list[autoloot_handle][autoloot_enable_move]=0 then
      --check stats of loot bag and loot1
      puts(1,"would looting in teleport function\n")
      if autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][ autolootbots_list[autoloot_handle][autoloot_lootbag_id] ]!=0 then
      	stats=player_stats_get(autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][ autolootbots_list[autoloot_handle][autoloot_lootbag_id] ])
      	for j=9 to 9+7 do
      	  if stats[j][2]!=-1 then
      	  	if item_index[stats[j][2]][2]=1  then--this means the item is on the auto loot list
      	  	puts(1,"looting in teleport function\n")
      	  	  mystats=player_stats_get(autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][ client_list[client][client_object_id] ])
      	  	  for k=13 to 13+7 do
      	  	    if mystats[k][2]=-1 then
      	  	      --autolootbots_list[autoloot_handle][autoloot_px]
      	  	      usleep(500)
      	  	      inv_swap(mystats[k],stats[j], client_list[client][client_object_id] ,autolootbots_list[autoloot_handle][autoloot_lootbag_id], autolootbots_list[autoloot_handle][autoloot_px], autolootbots_list[autoloot_handle][autoloot_py], client )
      	  	      exit
      	  	    end if
              end for
              exit
            end if
          end if
        end for
      end if
    end if
    autolootbots_list[autoloot_handle][autoloot_enable_move]=1
  end if
end procedure


procedure new_tick_packet_read(integer client,integer inputstream)
  integer player_handle,autoloot_handle
  integer size,tick_id,tick_time
  sequence temp,write,stats,data,mystats
  integer object_id,statdata_size,statdata_type,found_loot
  atom x,y,angle,mx,my,tx,ty,lootx,looty,ttime,speed,stime

  atom dist,dist_small,player_small,dtime

  atom tstart

  tstart=get_tick_count()

  tick_id=input_stream_readint(inputstream)
  tick_time=input_stream_readint(inputstream)
  size=input_stream_readshort(inputstream)

  autoloot_handle=client_list[client][client_data]




  stats=repeat({},stats_size) --the most number of stats a object can have


  for i=1 to size do

    object_id=input_stream_readint(inputstream)
    x=input_stream_readfloat(inputstream)
    y=input_stream_readfloat(inputstream)

    player_handle=autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][object_id]

    if player_handle!=0 then-- if object_id_to_player_class[object_id]!=0 then
      stats=player_stats_get(player_handle)
      statdata_size=input_stream_readshort(inputstream)
      for j=1 to statdata_size do
        statdata_type=input_stream_readbyte(inputstream)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 then
          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}
        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
        end if
      end for
    else-- if object_id_to_player_class[object_id]!=0 then
      statdata_size=input_stream_readshort(inputstream)
      for j=1 to statdata_size do
        statdata_type=input_stream_readbyte(inputstream)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 then
          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}
        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
        end if
      end for
    end if -- if object_id_to_player_class[object_id]!=0 then

    if player_handle!=0 then --object to be updated is a player or loobag lol


      if object_id=client_list[client][client_object_id] then --my inventory
        --puts(1,"done\n")
      	--for j=9 to 9+11 do
      	  --?stats[j]	
      	--end for
      end if



      if player_class_get(player_handle)=1280 then
      	--puts(1,"loot bag tick\n")
      	
      	for j=9 to 9+7 do
      	  --?stats[j]	
      	  if stats[j][2]!=-1 then
      	  	if item_index[stats[j][2]][2]=1  then--this means the item is on the auto loot list
      	  	  if find(object_id, loot_bag_ids)=0 and autolootbots_list[autoloot_handle][autoloot_teleport_cooldown]=0 then --loot bag as not been seen yet
      	  	    puts(1,"would loot "&item_index[stats[j][2]][3]&"\n")	
      	  	    --data=get_grid(x,y) --list of player handerles
      	  	    found_loot=0
      	  	    dist_small=10
      	  	    player_small=0
      	  	    puts(1,"dist checking\n")
      	  	    dtime=get_tick_count()
      	  	    ?dtime
      	  	    for k=1 to length(player_class_list) do
      	  	      if length(player_class_list[k]) and player_class_list[k][player_client]=client and player_class_list[k][player_class]!=1280 then
      	  	        dist=point_distance(player_class_list[k][player_position][1],player_class_list[k][player_position][2],x,y)
      	  	        if dist<dist_small then
      	  	          dist_small=dist	
      	  	          player_small=k
      	  	        end if
                  end if
                end for
                ?get_tick_count()-dtime
      	  	     mystats=player_stats_get(autolootbots_list[autoloot_handle][7][ client_list[client][client_object_id] ])
      	  	        for l=13 to 13+7 do
      	  	          if mystats[l][2]=-1 then
      	  	            puts(1,"found\n")
      	  	            ?get_tick_count()-tstart
      	  	            autolootbots_list[autoloot_handle][autoloot_timing]=get_tick_count()
      	  	 	        autolootbots_list[autoloot_handle][autoloot_target_id]=player_class_list[player_small][player_object_id]
      	  	 	        write=""
      	  	 	        autolootbots_list[autoloot_handle][autoloot_enable_move]=0
  	                    write=writeint(write,player_class_list[player_small][player_object_id])
                        temp=reverse(int_to_bytes(length(write)+5)) &49
                        write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
                        socket_send_data(client_list[client][client_socket],temp&write)
                        loot_bag_ids&=object_id
                        autolootbots_list[autoloot_handle][autoloot_lootbag_id]=object_id
                        autolootbots_list[autoloot_handle][autoloot_lootx]=x
                        autolootbots_list[autoloot_handle][autoloot_looty]=y
                        found_loot=1
                        exit --l
                      end if
                    end for--l

      	  	    exit --j
      	  	  end if
      	  	end if
      	  end if
      	end for--j
      	
      end if


      player_update(  player_handle ,stats, {x,y}, {0,0} )
    end if

  end for --i


  mx=autolootbots_list[autoloot_handle][autoloot_mx]
  my=autolootbots_list[autoloot_handle][autoloot_my]

  tx=autolootbots_list[autoloot_handle][autoloot_tx]
  ty=autolootbots_list[autoloot_handle][autoloot_ty]

  --?current_time()-client_list[client][client_last_move_time]

  if autolootbots_list[autoloot_handle][autoloot_enable_move]=1 and point_distance( mx, my, tx, ty)>1 then
    --?point_distance( autolootbots_list[client_list[client][client_data]][3], autolootbots_list[client_list[client][client_data]][4], autolootbots_list[client_list[client][client_data]][5], autolootbots_list[client_list[client][client_data]][6])
    angle=get_angle_to(mx,my,tx,ty)
    speed=SPEED_BASE + (SPEED_MULTIPLIER)
    stime=current_time()-client_list[client][client_last_move_time]

    --if client=1 then
    --?(stime * speed)*sin(degtorad(angle))
    --end if
      if stime>600 then
      	stime=600
      end if


    autolootbots_list[autoloot_handle][autoloot_mx]+=(stime * speed)*sin(degtorad(angle))
    autolootbots_list[autoloot_handle][autoloot_my]-=(stime * speed)*cos(degtorad(angle))

  elsif autolootbots_list[autoloot_handle][autoloot_enable_move]=0 and point_distance( mx, my, autolootbots_list[autoloot_handle][autoloot_lootx], autolootbots_list[autoloot_handle][autoloot_looty])>0.6 then
    puts(1,"moving in new tick function\n")
    angle=get_angle_to(mx,my,tx,ty)
    speed=SPEED_BASE + (SPEED_MULTIPLIER)
    stime=current_time()-client_list[client][client_last_move_time]
    --if client=1 then
    --?(stime * speed)*sin(degtorad(angle))
    --end if
      if stime>600 then
      	stime=600
      end if

  	angle=get_angle_to(mx,my ,autolootbots_list[autoloot_handle][autoloot_lootx],autolootbots_list[autoloot_handle][autoloot_looty])
    autolootbots_list[autoloot_handle][autoloot_mx]+=(stime * speed)*sin(degtorad(angle))
    autolootbots_list[autoloot_handle][autoloot_my]-=(stime * speed)*cos(degtorad(angle))
  else
    if autolootbots_list[autoloot_handle][autoloot_enable_move]=0 then
      --check stats of loot bag and loot1
      puts(1,"looting in new tick function\n")
      if autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][ autolootbots_list[autoloot_handle][autoloot_lootbag_id] ]!=0 then
      	stats=player_stats_get(autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][ autolootbots_list[autoloot_handle][autoloot_lootbag_id] ])
      	for j=9 to 9+7 do
      	  if stats[j][2]!=-1 then
      	  	if item_index[stats[j][2]][2]=1  then--this means the item is on the auto loot list
      	  	  mystats=player_stats_get(autolootbots_list[autoloot_handle][autoloot_object_id_to_player_class][ client_list[client][client_object_id] ])
      	  	  for k=13 to 13+7 do
      	  	    if mystats[k][2]=-1 then
      	  	      inv_swap(mystats[k],stats[j], client_list[client][client_object_id] ,autolootbots_list[autoloot_handle][autoloot_lootbag_id], autolootbots_list[autoloot_handle][3], autolootbots_list[autoloot_handle][4], client )
      	  	      exit
      	  	    end if
              end for
              exit
            end if
          end if
        end for
      end if
    end if
    autolootbots_list[autoloot_handle][autoloot_enable_move]=1
  end if

  autolootbots_list[autoloot_handle][autoloot_px]=mx
  autolootbots_list[autoloot_handle][autoloot_py]=my


  write=""
  write=writeint(write,tick_id) --tick id
  ttime=current_time()
  write=writeint(write,ttime) --time
  client_list[client][client_last_move_time]=ttime
  --position
  write=writefloat(write,autolootbots_list[client_list[client][client_data]][3])
  write=writefloat(write,autolootbots_list[client_list[client][client_data]][4])

  write=writeshort(write,0)
  --Move = 7;
  temp=reverse(int_to_bytes(length(write)+5)) &move_packet
  write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
  socket_send_data(client_list[client][client_socket],temp&write)
end procedure
packet_read_id[new_tick_packet+1]=routine_id("new_tick_packet_read")


procedure goto_packet_read(integer client,integer inputstream)
  object res
  integer  autoloot_handle
  sequence write,temp



  res=input_stream_readint(inputstream)
  if client_list[client][client_object_id]=res then
    --puts(1,"crapballs\n")
    autoloot_handle=client_list[client][client_data]

  	res=input_stream_readfloat(inputstream)
  	autolootbots_list[autoloot_handle][3]=res
    res=input_stream_readfloat(inputstream)
    autolootbots_list[autoloot_handle][4]=res
    autolootbots_list[autoloot_handle][autoloot_target_id]=-1



    remove_loot_bag_id(autolootbots_list[autoloot_handle][autoloot_lootbag_id])
    autolootbots_list[autoloot_handle][autoloot_teleport_cooldown]=10 --set this here teleport cool down

    puts(1,"teleport\n")
    ?get_tick_count()-autolootbots_list[autoloot_handle][autoloot_timing]
    autolootbots_list[autoloot_handle][autoloot_timing]=get_tick_count()

    move(client,autoloot_handle)

  else
    res=input_stream_readfloat(inputstream)
    res=input_stream_readfloat(inputstream)
  end if

  write=""
  write=writeint(write,current_time()) --time

  temp=reverse(int_to_bytes(length(write)+5)) &gotoack_packet
  write=rc4_arcfour_encrypt_block(client_list[client][client_rc4_2],write)
  socket_send_data(client_list[client][client_socket],temp&write)
end procedure

packet_read_id[goto_packet+1]=routine_id("goto_packet_read")


procedure invresult_packet_read(integer client,integer inputstream)
  sequence mystats
  object res
  integer autoloot_handle
  res=input_stream_readint(inputstream)
  puts(1,"invresult\n")
  ?res
  autoloot_handle=client_list[client][client_data]
  if res=0 then

   --stats=player_stats_get(autolootbots_list[client_list[client][client_data]][7][ client_list[client][client_object_id] ])
  	--autolootbots_list[client_list[client][client_data]][7][ client_list[client][client_object_id] ]
     mystats=player_stats_get(autolootbots_list[autoloot_handle][7][ client_list[client][client_object_id] ])
     for k=12 to 12+7 do
      	if mystats[k][2]=-1 then
      	  mystats[k][2]=autolootbots_list[autoloot_handle][14]	
      	  player_stats_set(autolootbots_list[autoloot_handle][7][ client_list[client][client_object_id] ],mystats)
      	  if isChecked(checkbox_sound_looted)=1 then
           VOID = playSound("button-3.wav")	
          end if
      	  exit
      	end if
     end for
  end if

  ?get_tick_count()-autolootbots_list[autoloot_handle][autoloot_timing]
end procedure

packet_read_id[invresult_packet+1]=routine_id("invresult_packet_read")



procedure read_packet(integer client)
  sequence data,fail_message
  integer inputstream,packet_id,packet_len
  object ret

  --puts(1,"location class size "&sprint(location_classsize())&"\n")
  --puts(1,"object_status class size "&sprint(object_status_classsize())&"\n")
  --puts(1,"object_status_data class size "&sprint(object_status_data_classsize())&"\n")
  --puts(1,"stat_data class size "&sprint(stat_data_classsize())&"\n")
  --puts(1,"tile class size "&sprint(tile_classsize())&"\n")

  --puts(1,"size of  player_class_list "&sprint(length(player_class_list))&"\n")

  inputstream=client_list[client][client_inputstream]


  while 1 do
  	

  if input_stream_length(inputstream)>=5 and input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
  else
    exit
  end if

  packet_id=input_stream_peek(inputstream,5)
  packet_len=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} )
	
  --puts(1,packet_names[packet_id+1]&"\n")

  if input_stream_length(inputstream)>=5 then
  	data=rc4_arcfour_encrypt_block(client_list[client][client_rc4_1],input_stream_slice(inputstream,6,packet_len))
  	
  	input_stream_set(inputstream, input_stream_slice(inputstream,packet_len+1, input_stream_length(inputstream) ) )
  	if packet_id=update_packet and autolootbots_list[client_list[client][client_data]][2]=0 then
  	  autolootbots_list[client_list[client][client_data]][2]=1
  	  process_update_packet(client,data)
  	else
  	   input_stream_set(inputstream, data&input_stream_get(inputstream))	
  	end if
  	
  	
  end if

  if packet_id=fail_packet then
    puts(1,"fail ")
  	?input_stream_readint(inputstream)
  	fail_message=input_stream_readutf(inputstream)
  	puts(1,fail_message&"\n")
    WsockCloseSocket(client_list[client][client_socket])
  	if length(fail_message)>6 then
  	  if fail_message[1]='A' and fail_message[2]='c' then
  	  	--account
  	  	--puts(1,"accouct in use found \n")
  	  	--accounts[client_list[client][client_account_id]][5]=0
        --client_list=remove_line(client_list,client)
  	  end if	
  	end if
  	
  	input_stream_set(inputstream, "")
  	
    --if match("Lost connection",fail_message) then
  	--  accounts[client_list[client][client_account_id]][5]=0
  	--  connect_to_server()
  	--end if
  	
  	exit
  end if

  if packet_read_id[packet_id+1]!=-1 then
    client_set_packet_len(client,packet_len)--new fix mapload packet
    if autolootbots_list[client_list[client][client_data]][2]=1 and packet_id=update_packet then
     socket_send_data(client_list[client][client_socket],reverse(int_to_bytes(length("")+5)) &updateatt_packet)
     autolootbots_list[client_list[client][client_data]][2]=2 --first update logic
    else
       call_proc(packet_read_id[packet_id+1], {client,inputstream})	
    end if

  else
   puts(1,"read unknow packet with id:"&sprint(packet_id))
   WsockCloseSocket(client_list[client][client_socket])
   input_stream_set(inputstream, "")
   exit
  end if

  end while
end procedure

--sequence fd_read,fd_data
--fd_read=repeat(0,65536)
--fd_data=repeat({},65536)


procedure newread(integer sock)
 atom      index, newsock
  integer   action,  iwork,inputstream
  object    owork,junk
  sequence  newIP,swork,rx,tx
  sequence  data


    rx = ""
    owork = WsockReadData_1024(sock,4096)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData_1024(sock,4096)
    end while

    if length(rx) > 0 then
      --fd_read[sock]+=1

      if sockets[sock]=0 then
      	return
      end if

      inputstream=client_list[sockets[sock]][client_inputstream]

      input_stream_append(inputstream,rx)

      if input_stream_length(inputstream)>=5 then
        --puts(1,"packet length "&sprint(bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)})) &"  : actual len:"&sprint(input_stream_length(inputstream)) &"\n" )
        --puts(1,"packet id:"&sprint(input_stream_peek(inputstream,5))&"\n")
        --fd_data[sock]={input_stream_length(inputstream), bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) }
        if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          read_packet(sockets[sock])	
        end if
      end if

    end if
	
end procedure

procedure processServerMessage(atom hWnd, atom arg1, atom arg2)
  atom      index, newsock
  integer   action, sock, iwork,inputstream,target_index
  object    owork,junk
  sequence  newIP,swork,rx,tx
  sequence  data

  action = lo_word(arg2)
  sock = arg1

  if action=FD_CONNECT then
  	puts(1,"connected\n")
  	
    if sockets[sock]=0 then
       --target_index=1
      for i=1 to length(accounts) do
      	if accounts[i][5]=0 then
      	  target_index=i
      	  accounts[i][5]=1
      	  exit	
      	end if
      end for

      index=autolootbot_create()
      --autolootbots_list[index][5]=134
      --autolootbots_list[index][6]=140
      autolootbots_list[index][5]=real(accounts[target_index][3])
      autolootbots_list[index][6]=real(accounts[target_index][4])


      --fd_data[sock]={0,0}
      --fd_read[sock]=1
      --
      sockets[sock]=client_new(accounts[target_index][1],accounts[target_index][2],"",sock,index,target_index)
      --sockets[sock]=client_new("","","",sock,index,1)

      iwork=WsockSendData(sock,hello_packet_write(sockets[sock],accounts[target_index][1],accounts[target_index][2]))
  	  --socket_send_data(sock,hello_packet_write(sockets[sock],create_random_guild(),""))
  	  --socket_send_data(sock,create_packet_write(sockets[sock]))
  	  --socket_send_data(sock,create_packet_write(sockets[sock]))
      iwork=WsockSendData(sock,load_packet_write(sockets[sock],1))


    else

      puts(1,"error socket already in use\n")
	
    end if

  	
  elsif action = FD_READ then
    rx = ""
    owork = WsockReadData_1024(sock,4096)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData_1024(sock,4096)
    end while

    if length(rx) > 0 then

      --fd_read[sock]+=1

      if sockets[sock]=0 then
      	return
      end if

      inputstream=client_list[sockets[sock]][client_inputstream]

      input_stream_append(inputstream,rx)

      if input_stream_length(inputstream)>=5 then
        --puts(1,"packet length "&sprint(bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)})) &"  : actual len:"&sprint(input_stream_length(inputstream)) &"\n" )
        --puts(1,"packet id:"&sprint(input_stream_peek(inputstream,5))&"\n")
        --fd_data[sock]={input_stream_length(inputstream), bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) }
        if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          read_packet(sockets[sock])	
        end if
      end if

    end if
  elsif action = FD_CLOSE then
     puts(1,"server closed\n")
     WsockCloseSocket(sock)


     accounts[client_list[sockets[sock]][client_account_id]][5]=0
     autolootbots_list=remove_line(autolootbots_list,client_list[sockets[sock]][client_data])
     client_list=remove_line(client_list,sockets[sock])
     puts(1,"computer \n")
     ?length(client_list)

     sockets[sock]=0
  	 connect_to_server()
     -- need to free the client
  end if
end procedure
#EndProc

#Proc: onClose
procedure Window1_onClose (integer self, integer event, sequence params)--params is ()
  --WsockCloseSocket(Server_sock)
end procedure
setHandler( Window1, w32HClose, routine_id("Window1_onClose"))
#EndProc

#Proc: onEvent
procedure Window1_onEvent (integer self, integer event, sequence params)--params is ( int iMsg, atom wParm, atom lParm )
  if params[1] = SM_ASYNC then
	processServerMessage(hWndMainWindow,params[2],params[3])
  end if
end procedure
setHandler( Window1, w32HEvent, routine_id("Window1_onEvent"))
#EndProc

#Proc: onTimer
procedure Window1_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
sequence text,data
  if params[1]=1001 then
    --connect_to_server()
  	--killTimer(Window1,1001)
  	--text=""
  	--data=""
  	--repaintWindow(Window1)
  	  --for i=1 to 65536 do
      	--if fd_read[i]!=0 then
      	--  text&=sprint(fd_read[i])&", "
      	--end if
      	--if length(fd_data[i]) then
      	  --data&=sprint(fd_data[i][1])&", "&sprint(fd_data[i][2])&" : "	
      	  --data&=sprint(client_list[sockets[i]][client_packet_len])&"  "&sprint(input_stream_length(client_list[sockets[i]][client_inputstream]))&"  "
      	--end if
      --end for

      --wPuts({Window1,1,1},text)
      --wPuts({Window1,1,20},data)
  elsif params[1]=1002  then
  	for i=1 to length(client_list) do
  	  if length(client_list[i]) then
  	  	--read_packet(i)
  	  	newread(client_list[i][7])
  	  end if	
  	end for
  	
    for i=1 to length(autolootbots_list) do
      autolootbots_list[i][11]-=1	
      if autolootbots_list[i][11]<0	then
      	autolootbots_list[i][11]=0
      end if
    end for
  elsif params[1]=3000 then
    globalcount+=1
    --if globalcount>=length(accounts) then
    if globalcount>=globallimt then
       killTimer(Window1,3000)	
    end if
    --?globalcount
  	connect_to_server()
  end if
end procedure
setHandler( Window1, w32HTimer, routine_id("Window1_onTimer"))
#EndProc

#Control: LText13
AWindow : 30
X       : 10
Y       : 10
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Server :
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 9
Local : 1
OrigTitle : LText13

#Control: combox_serverlist
AWindow : 30
X       : 70
Y       : 10
CX      : 150
CY      : 20
ControlLayer: 0
Title   : 
Class   : Combo
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 1
Local : 1
OrigTitle : Combo12

#Control: checkbox_sound_looted
AWindow : 30
X       : 240
Y       : 10
CX      : 90
CY      : 20
ControlLayer: 0
Title   : Sound on loot
Class   : CheckBox
Enabled : 0
Checked : 1
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 11
Local : 1
OrigTitle : CheckBox15

#Control: LText20
AWindow : 30
X       : 440
Y       : 10
CX      : 30
CY      : 20
ControlLayer: 0
Title   : Email:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 15
Local : 1
OrigTitle : LText20

#Control: textbox_email
AWindow : 30
X       : 470
Y       : 10
CX      : 110
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 13
Local : 1
OrigTitle : EditText18

#Control: LText26
AWindow : 30
X       : 580
Y       : 10
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Target x:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 21
Local : 1
OrigTitle : LText26

#Control: textbox_target_x
AWindow : 30
X       : 630
Y       : 10
CX      : 40
CY      : 20
ControlLayer: 0
Title   : 134
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Numeric : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 23
Local : 1
OrigTitle : EditText28

#Control: LText7
AWindow : 30
X       : 10
Y       : 40
CX      : 150
CY      : 20
ControlLayer: 0
Title   : List of all items:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 3
Local : 1
OrigTitle : LText7

#Control: LText8
AWindow : 30
X       : 220
Y       : 40
CX      : 150
CY      : 20
ControlLayer: 0
Title   : Items to auto loot:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 4
Local : 1
OrigTitle : LText8

#Control: LText21
AWindow : 30
X       : 420
Y       : 40
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Password:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 16
Local : 1
OrigTitle : LText21

#Control: textbox_password
AWindow : 30
X       : 470
Y       : 40
CX      : 110
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 14
Local : 1
OrigTitle : EditText19

#Control: LText27
AWindow : 30
X       : 580
Y       : 40
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Target y:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 22
Local : 1
OrigTitle : LText27

#Control: textbox_target_y
AWindow : 30
X       : 630
Y       : 40
CX      : 40
CY      : 20
ControlLayer: 0
Title   : 140
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Numeric : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 24
Local : 1
OrigTitle : EditText29

#Control: List_items
AWindow : 30
X       : 10
Y       : 60
CX      : 200
CY      : 300
ControlLayer: 0
Title   : 
Class   : SortedList
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 2
Local : 1
OrigTitle : List5

#Control: List_white_items
AWindow : 30
X       : 220
Y       : 60
CX      : 200
CY      : 300
ControlLayer: 0
Title   : 
Class   : SortedList
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
DirParent : LText8
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 5
Local : 1
OrigTitle : List6

#Control: PushButton23
AWindow : 30
X       : 440
Y       : 90
CX      : 70
CY      : 30
ControlLayer: 0
Title   : Add
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 18
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton23

#Proc: onClick
procedure PushButton23_onClick (integer self, integer event, sequence params)--params is ()

  if getCount( List_accounts )>=globallimt then
   return
  end if


  if length(getText(textbox_email)) and length(getText(textbox_password)) and length(getText(textbox_target_x)) and length(getText(textbox_target_y)) then
  	addItem(List_accounts,getText(textbox_email)&":"&getText(textbox_password)&":"&getText(textbox_target_x)&":"&getText(textbox_target_y))
  	accounts=append(accounts,{getText(textbox_email),getText(textbox_password),getText(textbox_target_x),getText(textbox_target_y),0})
  end if



end procedure
setHandler( PushButton23, w32HClick, routine_id("PushButton23_onClick"))
#EndProc

#Control: PushButton24
AWindow : 30
X       : 520
Y       : 90
CX      : 60
CY      : 30
ControlLayer: 0
Title   : Remove
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 19
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton24

#Proc: onClick
procedure PushButton24_onClick (integer self, integer event, sequence params)--params is ()
  integer index,ret

  index=getIndex(List_accounts)
  if index=0 then
  	return
  end if

  ret=deleteItem( List_accounts, index )
  setIndex(List_accounts,index)
  accounts=remove_line(accounts,index)


end procedure
setHandler( PushButton24, w32HClick, routine_id("PushButton24_onClick"))
#EndProc

#Control: PushButton25
AWindow : 30
X       : 590
Y       : 90
CX      : 80
CY      : 30
ControlLayer: 0
Title   : Save accounts
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 20
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton25

#Proc: onClick
procedure PushButton25_onClick (integer self, integer event, sequence params)--params is ()

  integer fn
  object ret

  ret=0
  if file_exsist("accounts.txt") then
    ret = message_box("Warning account.txt already exists do you the file to be overwritten?","Warning",MB_YESNO)	
  end if

  if ret=IDNO then
    returnValue(1)
    return
  end if

  fn=open("accounts.txt","w")
  for i=1 to length(accounts) do
  	puts(fn, accounts[i][1]&"\n" )
  	puts(fn, accounts[i][2]&"\n" )
  	puts(fn, accounts[i][3]&"\n" )
  	puts(fn, accounts[i][4]&"\n" )
  end for
  close(fn)


end procedure
setHandler( PushButton25, w32HClick, routine_id("PushButton25_onClick"))
#EndProc

#Control: LText22
AWindow : 30
X       : 430
Y       : 130
CX      : 150
CY      : 20
ControlLayer: 0
Title   : Accounts:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 17
Local : 1
OrigTitle : LText22

#Control: List_accounts
AWindow : 30
X       : 430
Y       : 150
CX      : 250
CY      : 150
ControlLayer: 0
Title   : 
Class   : List
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 12
Local : 1
OrigTitle : List16

#Control: PushButton9
AWindow : 30
X       : 60
Y       : 360
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Add
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 6
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton9

#Proc: onClick
procedure PushButton9_onClick (integer self, integer event, sequence params)--params is ()
integer index
object ret
  index=getIndex(List_items)
  if index=0 then
  	return
  end if
  addItem(List_white_items,getItem(List_items,index))
  ret=deleteItem( List_items, index )
  setIndex(List_items,index)
  mark_white_item()
end procedure
setHandler( PushButton9, w32HClick, routine_id("PushButton9_onClick"))
#EndProc

#Control: PushButton10
AWindow : 30
X       : 260
Y       : 360
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Remove
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 7
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton10

#Proc: onClick
procedure PushButton10_onClick (integer self, integer event, sequence params)--params is ()
  integer index
object ret
  index=getIndex(List_white_items)
  if index=0 then
  	return
  end if
  addItem(List_items,getItem(List_white_items,index))
  ret=deleteItem( List_white_items, index )
  setIndex(List_white_items,index)

  mark_white_item()
end procedure
setHandler( PushButton10, w32HClick, routine_id("PushButton10_onClick"))
#EndProc

#Control: PushButton11
AWindow : 30
X       : 420
Y       : 360
CX      : 80
CY      : 30
ControlLayer: 0
Title   : Save Items
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 8
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton11

#Proc: onClick
procedure PushButton11_onClick (integer self, integer event, sequence params)--params is ()
sequence text
integer fn
  fn=open("items.txt","w")
  for i=1 to getCount( List_white_items ) do
  	text = getItem( List_white_items, i )
  	puts(fn,text&"\n")
  end for
  close(fn)
end procedure
setHandler( PushButton11, w32HClick, routine_id("PushButton11_onClick"))
#EndProc

#Control: PushButton14
AWindow : 30
X       : 520
Y       : 360
CX      : 80
CY      : 30
ControlLayer: 0
Title   : Connect
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 10
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton14

#Proc: onClick
procedure PushButton14_onClick (integer self, integer event, sequence params)--params is ()

if length(accounts) then
  setEnable(PushButton14,0)

  --for i=1 to length(accounts) do
  for i=1 to 30 do
  	  --connect_to_server()
  end for

  globalcount=0
  setTimer(Window1,3000,1000)

end if


end procedure
setHandler( PushButton14, w32HClick, routine_id("PushButton14_onClick"))
#EndProc

